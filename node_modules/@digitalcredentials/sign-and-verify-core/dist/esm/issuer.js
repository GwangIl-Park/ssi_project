var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { getCustomLoader, addDidDocuments, getPreloadedAssertionMethods } from './common';
import { getSigningKeyIdentifier, getSigningDate } from './signatures';
import { Ed25519VerificationKey2020 } from '@digitalcredentials/ed25519-verification-key-2020';
import { Ed25519Signature2020 } from '@digitalcredentials/ed25519-signature-2020';
import vc from '@digitalcredentials/vc';
export function createIssuer(unlockedDIDDocuments, defaultSigningIdentifier) {
    let customLoaderProto = getCustomLoader();
    customLoaderProto = addDidDocuments(customLoaderProto, unlockedDIDDocuments);
    let customLoader = customLoaderProto.buildDocumentLoader();
    const unlockedAssertionMethods = getPreloadedAssertionMethods(unlockedDIDDocuments);
    function createKey(assertionMethod) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyInfo = unlockedAssertionMethods.get(assertionMethod);
            if (!keyInfo) {
                throw new Error(`key for assertionMethod ${assertionMethod} not found`);
            }
            return new Ed25519VerificationKey2020(keyInfo);
        });
    }
    function createSigningKey(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const signingKey = yield createKey(getSigningKeyIdentifier(options));
            return new Ed25519Signature2020({
                key: signingKey,
                date: getSigningDate(options)
            });
        });
    }
    function sign(credential, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const suite = yield createSigningKey(options);
            // this library attaches the signature on the original object, so make a copy
            const credCopy = JSON.parse(JSON.stringify(credential));
            try {
                return vc.issue({
                    credential: credCopy,
                    suite: suite,
                    documentLoader: customLoader
                });
            }
            catch (e) {
                console.error(e);
                throw e;
            }
        });
    }
    function signPresentation(presentation, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const suite = yield createSigningKey(options);
            return vc.signPresentation({
                presentation: presentation,
                documentLoader: customLoader,
                suite: suite,
                challenge: options.challenge
            });
        });
    }
    function createAndSignPresentation(credential, presentationId, holder, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const suite = yield createSigningKey(options);
            const presentation = vc.createPresentation({
                verifiableCredential: credential,
                id: presentationId,
                holder: holder,
            });
            return vc.signPresentation({
                presentation: presentation,
                documentLoader: customLoader,
                suite: suite,
                challenge: options.challenge
            });
        });
    }
    return {
        createKey,
        createSuite: createSigningKey,
        sign,
        signPresentation,
        createAndSignPresentation
    };
}
//# sourceMappingURL=issuer.js.map