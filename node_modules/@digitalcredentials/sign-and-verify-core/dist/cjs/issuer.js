"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIssuer = void 0;
const common_1 = require("./common");
const signatures_1 = require("./signatures");
const ed25519_verification_key_2020_1 = require("@digitalcredentials/ed25519-verification-key-2020");
const ed25519_signature_2020_1 = require("@digitalcredentials/ed25519-signature-2020");
const vc_1 = __importDefault(require("@digitalcredentials/vc"));
function createIssuer(unlockedDIDDocuments, defaultSigningIdentifier) {
    let customLoaderProto = common_1.getCustomLoader();
    customLoaderProto = common_1.addDidDocuments(customLoaderProto, unlockedDIDDocuments);
    let customLoader = customLoaderProto.buildDocumentLoader();
    const unlockedAssertionMethods = common_1.getPreloadedAssertionMethods(unlockedDIDDocuments);
    function createKey(assertionMethod) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyInfo = unlockedAssertionMethods.get(assertionMethod);
            if (!keyInfo) {
                throw new Error(`key for assertionMethod ${assertionMethod} not found`);
            }
            return new ed25519_verification_key_2020_1.Ed25519VerificationKey2020(keyInfo);
        });
    }
    function createSigningKey(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const signingKey = yield createKey(signatures_1.getSigningKeyIdentifier(options));
            return new ed25519_signature_2020_1.Ed25519Signature2020({
                key: signingKey,
                date: signatures_1.getSigningDate(options)
            });
        });
    }
    function sign(credential, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const suite = yield createSigningKey(options);
            // this library attaches the signature on the original object, so make a copy
            const credCopy = JSON.parse(JSON.stringify(credential));
            try {
                return vc_1.default.issue({
                    credential: credCopy,
                    suite: suite,
                    documentLoader: customLoader
                });
            }
            catch (e) {
                console.error(e);
                throw e;
            }
        });
    }
    function signPresentation(presentation, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const suite = yield createSigningKey(options);
            return vc_1.default.signPresentation({
                presentation: presentation,
                documentLoader: customLoader,
                suite: suite,
                challenge: options.challenge
            });
        });
    }
    function createAndSignPresentation(credential, presentationId, holder, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const suite = yield createSigningKey(options);
            const presentation = vc_1.default.createPresentation({
                verifiableCredential: credential,
                id: presentationId,
                holder: holder,
            });
            return vc_1.default.signPresentation({
                presentation: presentation,
                documentLoader: customLoader,
                suite: suite,
                challenge: options.challenge
            });
        });
    }
    return {
        createKey,
        createSuite: createSigningKey,
        sign,
        signPresentation,
        createAndSignPresentation
    };
}
exports.createIssuer = createIssuer;
//# sourceMappingURL=issuer.js.map