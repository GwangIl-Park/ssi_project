"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProofProperty = exports.getSigningDate = exports.getSigningKeyIdentifier = exports.SignatureOptions = exports.DefaultProofPurpose = void 0;
exports.DefaultProofPurpose = 'assertionMethod';
const SecurityPrefix = 'https://w3id.org/security';
class SignatureOptions {
    constructor(options) {
        this.proofPurpose = exports.DefaultProofPurpose;
        Object.assign(this, options);
    }
}
exports.SignatureOptions = SignatureOptions;
// Added to work around confusing naming schemes. Later, there may be some layer of indirection
// but for now, it's just the verificationMethod for our use cases.
function getSigningKeyIdentifier(options) {
    return options.verificationMethod;
}
exports.getSigningKeyIdentifier = getSigningKeyIdentifier;
;
function getSigningDate(options) {
    return options.created ? options.created : new Date().toISOString();
}
exports.getSigningDate = getSigningDate;
;
function getProofProperty(vpProof, property) {
    let propValue = null;
    if (vpProof.hasOwnProperty(property)) {
        propValue = vpProof[property];
    }
    else if (vpProof.hasOwnProperty(`${SecurityPrefix}#${property}`)) {
        propValue = vpProof[`${SecurityPrefix}#${property}`];
    }
    else {
        throw new Error(`Invalid proof property ${property}`);
    }
    if (propValue.hasOwnProperty('id')) {
        return propValue.id;
    }
    return propValue;
}
exports.getProofProperty = getProofProperty;
//# sourceMappingURL=signatures.js.map