"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPreloadedAssertionMethods = exports.addDidDocuments = exports.getCustomLoader = exports.getController = void 0;
const jsonld_document_loader_1 = require("@transmute/jsonld-document-loader");
const dcc_context_1 = __importDefault(require("@digitalcredentials/dcc-context"));
const open_badges_context_1 = __importDefault(require("@digitalcredentials/open-badges-context"));
const didContext = require('@digitalcredentials/did-context');
const ed25519 = require('ed25519-signature-2020-context');
const x25519Ctx = require('x25519-key-agreement-2020-context');
function getController(fullDid) {
    return fullDid.split('#')[0];
}
exports.getController = getController;
function getCustomLoader() {
    const customLoaderProto = jsonld_document_loader_1.documentLoaderFactory.pluginFactory
        .build({
        contexts: Object.assign(Object.assign(Object.assign({}, jsonld_document_loader_1.contexts.W3C_Verifiable_Credentials), jsonld_document_loader_1.contexts.W3ID_Security_Vocabulary), jsonld_document_loader_1.contexts.W3C_Decentralized_Identifiers),
    })
        .addContext({ [ed25519.constants.CONTEXT_URL]: ed25519.contexts.get(ed25519.constants.CONTEXT_URL) })
        .addContext({ [didContext.constants.DID_CONTEXT_URL]: didContext.contexts.get(didContext.constants.DID_CONTEXT_URL) })
        .addContext({ [dcc_context_1.default.CONTEXT_URL_V1]: dcc_context_1.default.CONTEXT_V1 })
        // Open Badges v3 Context (with multiple URL aliases)
        .addContext({ [open_badges_context_1.default.CONTEXT_URL_V3]: open_badges_context_1.default.CONTEXT_V3 })
        .addContext({ [open_badges_context_1.default.constants.CONTEXT_URL_V3_JFF_V1]: open_badges_context_1.default.CONTEXT_V3 })
        .addContext({ [open_badges_context_1.default.constants.CONTEXT_URL_V3_IMS]: open_badges_context_1.default.CONTEXT_V3 })
        .addContext({ [x25519Ctx.constants.CONTEXT_URL]: x25519Ctx.contexts.get(x25519Ctx.constants.CONTEXT_URL) });
    return customLoaderProto;
}
exports.getCustomLoader = getCustomLoader;
function addDidDocuments(customLoaderProto, preloadedDidDocuments) {
    preloadedDidDocuments.forEach((didDoc) => {
        customLoaderProto.addResolver({
            [didDoc.id]: {
                resolve: (_did) => __awaiter(this, void 0, void 0, function* () {
                    return didDoc;
                }),
            },
        });
    });
    return customLoaderProto;
}
exports.addDidDocuments = addDidDocuments;
function getPreloadedAssertionMethods(preloadedDidDocuments) {
    const preloadedAssertionMethods = new Map();
    preloadedDidDocuments.forEach((didDoc) => {
        didDoc.assertionMethod.forEach((am) => {
            preloadedAssertionMethods.set(am.id, am);
        });
    });
    return preloadedAssertionMethods;
}
exports.getPreloadedAssertionMethods = getPreloadedAssertionMethods;
//# sourceMappingURL=common.js.map